class Maze{constructor(columns,rows){this.height=rows,this.width=columns,this.gates=[],this.direction={left:"left",right:"right",up:"up",down:"down"}}getRoute(maze2d,startX,startY,endX,endY){const goal=[xToTile(endX),xToTile(endY)];let route=[],t=this,visited=new Map;function cell(x,y){return maze2d[y][x]}function xToTile(x){return 2*x+1}function last(){return route[route.length-1][0]}function clean(){route.forEach((v,i,arr)=>{v.pop(),arr[i]=arr[i].pop()})}function getActions(x,y){let actions=[],left,up,down,right;return(x-1>=0?cell(x-1,y):null)&&!visited.has(x-1+"-"+y)&&actions.push("left"),(y-1>=0?cell(x,y-1):null)&&!visited.has(x+"-"+(y-1))&&actions.push("up"),(y+1<maze2d.length?cell(x,y+1):null)&&!visited.has(x+"-"+(y+1))&&actions.push("down"),(x+1<maze2d[0].length?cell(x+1,y):null)&&!visited.has(x+1+"-"+y)&&actions.push("right"),actions}function makeRoute(){for(;;){if(last()[0]==goal[0]&&last()[1]==goal[1])return clean(),route;if(route[route.length-1][1].length>0){let dir;move(route[route.length-1][1].pop())}else route.pop()}}function move(dir){let pos=last(),x=pos[0],y=pos[1];switch(dir){case"right":x+=1;break;case"left":x-=1;break;case"up":y-=1;break;case"down":y+=1}visited.set(x+"-"+y,!0),route.push([[x,y],getActions(x,y)])}return route.push([[xToTile(startX),xToTile(startY)],getActions(xToTile(startX),xToTile(startY))]),visited.set(startX+"-"+startY,!0),makeRoute()}cellsToTiles(cellsMap){let tileMap=new Array(2*this.height+1);for(let i=0;i<tileMap.length;i++)tileMap[i]=new Array(2*this.width+1).fill(0);return cellsMap.forEach((row,i)=>{let y=2*(i+1)-1;row.forEach((cel,c)=>{let x=2*(c+1)-1;tileMap[y][x]=1,tileMap[y-1][x]=cel[1],tileMap[y+1][x]=cel[2],tileMap[y][x-1]=cel[0],tileMap[y][x+1]=cel[3]})}),tileMap}gateway(x,y){this.gates.push([x,y])}tiles(){return this.cellsToTiles(this.cells())}cells(){let t=this,maze=[],cellsStack=[],cursor=[];for(let i=0;i<t.height;i++)maze.push(initRow());function initRow(){let row=[];for(let i=0;i<t.width;i++)row.push([0,0,0,0,1]);return row}function cell(x,y){return maze[y][x]}function getNonVisited(x,y){let freeOnes=[],left,up,down,right;return(x-1>=0?cell(x-1,y)[4]:null)&&freeOnes.push({x:x-1,y:y,to:"left"}),(y-1>=0?cell(x,y-1)[4]:null)&&freeOnes.push({x:x,y:y-1,to:"up"}),(y+1<t.height?cell(x,y+1)[4]:null)&&freeOnes.push({x:x,y:y+1,to:"down"}),(x+1<t.width?cell(x+1,y)[4]:null)&&freeOnes.push({x:x+1,y:y,to:"right"}),freeOnes}function move(direction){let x=cursor[0],y=cursor[1],dir;switch(direction){case t.direction.right:cell(x,y)[3]=1,cursor=[x+1,y],cell(x+1,y)[0]=1;break;case t.direction.left:cell(x,y)[0]=1,cursor=[x-1,y],cell(x-1,y)[3]=1;break;case t.direction.up:cell(x,y)[1]=1,cursor=[x,y-1],cell(x,y-1)[2]=1;break;case t.direction.down:cell(x,y)[2]=1,cursor=[x,y+1],cell(x,y+1)[1]=1}cell(cursor[0],cursor[1])[4]=0,cellsStack.push(cursor)}function generate(){for(cell((cursor=[Math.floor(Math.random()*(t.width-1)+1),Math.floor(Math.random()*(t.height-1)+1)])[0],cursor[1])[4]=0,cellsStack.push(cursor);;){let nearCells=getNonVisited(cursor[0],cursor[1]);for(;nearCells.length>0;){let idx,dir;move(nearCells[Math.floor(Math.random()*nearCells.length)].to),nearCells=getNonVisited(cursor[0],cursor[1])}if(!(cursor=cellsStack.pop()))break}}function setGateway(x,y){let start=cell(x,y);0==x?start[0]=1:0==y?start[1]=1:x==t.width-1?start[3]=1:y==t.height-1&&(start[2]=1)}function trimCells(){maze.forEach(row=>{row.forEach(c=>{c.pop()})})}return generate(),trimCells(),t.gates.forEach((v,i)=>{setGateway(v[0],v[1])}),maze}resetGates(){this.gates=[]}}