class Maze{constructor(columns,rows){this.height=rows,this.width=columns,this.gates=[],this.direction={left:"left",right:"right",up:"up",down:"down"}}gateway(x,y){this.gates.push([x,y])}map(){let t=this,maze=[],cellsStack=[],cursor=[];for(let i=0;i<t.height;i++)maze.push(initRow());function initRow(){let row=[];for(let i=0;i<t.width;i++)row.push([0,0,0,0,1]);return row}function getNonVisited(x,y){let freeOnes=[],left,up,down,right;return(x-1>=0?maze[y][x-1][4]:null)&&freeOnes.push({x:x-1,y:y,to:"left"}),(y-1>=0?maze[y-1][x][4]:null)&&freeOnes.push({x:x,y:y-1,to:"up"}),(y+1<t.height?maze[y+1][x][4]:null)&&freeOnes.push({x:x,y:y+1,to:"down"}),(x+1<t.width?maze[y][x+1][4]:null)&&freeOnes.push({x:x+1,y:y,to:"right"}),freeOnes}function move(direction){let x=cursor[0],y=cursor[1],dir;switch(direction){case t.direction.right:maze[y][x][3]=1,cursor=[x+1,y],maze[y][x+1][0]=1;break;case t.direction.left:maze[y][x][0]=1,cursor=[x-1,y],maze[y][x-1][3]=1;break;case t.direction.up:maze[y][x][1]=1,cursor=[x,y-1],maze[y-1][x][2]=1;break;case t.direction.down:maze[y][x][2]=1,cursor=[x,y+1],maze[y+1][x][1]=1}maze[cursor[1]][cursor[0]][4]=0,cellsStack.push(cursor)}function generate(){for(cursor=[Math.floor(Math.random()*(t.width-1)+1),Math.floor(Math.random()*(t.height-1)+1)],console.log([Math.floor(Math.random()*(t.width-1)),Math.floor(Math.random()*(t.height-1))]),maze[cursor[1]][cursor[0]][4]=0,cellsStack.push(cursor);;){let nearCells=getNonVisited(cursor[0],cursor[1]);for(;nearCells.length>0;){let idx,dir;move(nearCells[Math.floor(Math.random()*nearCells.length)].to),nearCells=getNonVisited(cursor[0],cursor[1])}if(!(cursor=cellsStack.pop()))break}}function setGateway(x,y){let start=maze[y][x];0==x?start[0]=1:0==y?start[1]=1:x==t.width-1?start[3]=1:y==t.height-1&&(start[2]=1)}return generate(),t.gates.forEach((v,i)=>{setGateway(v[0],v[1])}),window.maze=maze,maze}resetGates(){this.gates=[]}}