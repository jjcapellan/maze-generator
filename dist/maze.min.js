class Maze{constructor(columns,rows){this.height=rows,this.width=columns,this.gates=[],this.direction={left:"left",right:"right",up:"up",down:"down"}}cellsToTiles(cellsMap){let tileMap=new Array(2*this.height+1);for(let i=0;i<tileMap.length;i++)tileMap[i]=new Array(2*this.width+1).fill(0);return cellsMap.forEach((row,i)=>{let y=2*(i+1)-1;row.forEach((cel,c)=>{let x=2*(c+1)-1;tileMap[y][x]=1,tileMap[y-1][x]=cel[1],tileMap[y+1][x]=cel[2],tileMap[y][x-1]=cel[0],tileMap[y][x+1]=cel[3]})}),tileMap}gateway(x,y){this.gates.push([x,y])}tiles(){return this.cellsToTiles(this.cells())}cells(){let t=this,maze=[],cellsStack=[],cursor=[];for(let i=0;i<t.height;i++)maze.push(initRow());function initRow(){let row=[];for(let i=0;i<t.width;i++)row.push([0,0,0,0,1]);return row}function cell(x,y){return maze[y][x]}function getNonVisited(x,y){let freeOnes=[],left,up,down,right;return(x-1>=0?cell(x-1,y)[4]:null)&&freeOnes.push({x:x-1,y:y,to:"left"}),(y-1>=0?cell(x,y-1)[4]:null)&&freeOnes.push({x:x,y:y-1,to:"up"}),(y+1<t.height?cell(x,y+1)[4]:null)&&freeOnes.push({x:x,y:y+1,to:"down"}),(x+1<t.width?cell(x+1,y)[4]:null)&&freeOnes.push({x:x+1,y:y,to:"right"}),freeOnes}function move(direction){let x=cursor[0],y=cursor[1],dir;switch(direction){case t.direction.right:cell(x,y)[3]=1,cursor=[x+1,y],cell(x+1,y)[0]=1;break;case t.direction.left:cell(x,y)[0]=1,cursor=[x-1,y],cell(x-1,y)[3]=1;break;case t.direction.up:cell(x,y)[1]=1,cursor=[x,y-1],cell(x,y-1)[2]=1;break;case t.direction.down:cell(x,y)[2]=1,cursor=[x,y+1],cell(x,y+1)[1]=1}cell(cursor[0],cursor[1])[4]=0,cellsStack.push(cursor)}function generate(){for(cell((cursor=[Math.floor(Math.random()*(t.width-1)+1),Math.floor(Math.random()*(t.height-1)+1)])[0],cursor[1])[4]=0,cellsStack.push(cursor);;){let nearCells=getNonVisited(cursor[0],cursor[1]);for(;nearCells.length>0;){let idx,dir;move(nearCells[Math.floor(Math.random()*nearCells.length)].to),nearCells=getNonVisited(cursor[0],cursor[1])}if(!(cursor=cellsStack.pop()))break}}function setGateway(x,y){let start=cell(x,y);0==x?start[0]=1:0==y?start[1]=1:x==t.width-1?start[3]=1:y==t.height-1&&(start[2]=1)}function trimCells(){maze.forEach(row=>{row.forEach(c=>{c.pop()})})}return generate(),trimCells(),t.gates.forEach((v,i)=>{setGateway(v[0],v[1])}),maze}resetGates(){this.gates=[]}}