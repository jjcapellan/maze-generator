class Maze{constructor(columns,rows){this.height=rows,this.width=columns,this.gates=[],this.direction={left:"left",right:"right",up:"up",down:"down"}}cellsTotiles(cellsMap){let tileMap=new Array(3*this.height);for(let i=0;i<3*this.height;i++)tileMap[i]=new Array(3*this.width).fill(0);return cellsMap.forEach((row,i)=>{let y=3*i;row.forEach((cel,c)=>{let x=3*c;tileMap[y+1][x+1]=1,tileMap[y][x+1]=cel[1],tileMap[y+2][x+1]=cel[2],tileMap[y+1][x]=cel[0],tileMap[y+1][x+2]=cel[3]})}),tileMap}gateway(x,y){this.gates.push([x,y])}tiles(){return this.cellsTotiles(this.cells())}cells(){let t=this,maze=[],cellsStack=[],cursor=[];for(let i=0;i<t.height;i++)maze.push(initRow());function initRow(){let row=[];for(let i=0;i<t.width;i++)row.push([0,0,0,0,1]);return row}function cell(x,y){return maze[y][x]}function getNonVisited(x,y){let freeOnes=[],left,up,down,right;return(x-1>=0?cell(x-1,y)[4]:null)&&freeOnes.push({x:x-1,y:y,to:"left"}),(y-1>=0?cell(x,y-1)[4]:null)&&freeOnes.push({x:x,y:y-1,to:"up"}),(y+1<t.height?cell(x,y+1)[4]:null)&&freeOnes.push({x:x,y:y+1,to:"down"}),(x+1<t.width?cell(x+1,y)[4]:null)&&freeOnes.push({x:x+1,y:y,to:"right"}),freeOnes}function move(direction){let x=cursor[0],y=cursor[1],dir;switch(direction){case t.direction.right:cell(x,y)[3]=1,cursor=[x+1,y],cell(x+1,y)[0]=1;break;case t.direction.left:cell(x,y)[0]=1,cursor=[x-1,y],cell(x-1,y)[3]=1;break;case t.direction.up:cell(x,y)[1]=1,cursor=[x,y-1],cell(x,y-1)[2]=1;break;case t.direction.down:cell(x,y)[2]=1,cursor=[x,y+1],cell(x,y+1)[1]=1}cell(cursor[0],cursor[1])[4]=0,cellsStack.push(cursor)}function generate(){for(cursor=[Math.floor(Math.random()*(t.width-1)+1),Math.floor(Math.random()*(t.height-1)+1)],console.log([Math.floor(Math.random()*(t.width-1)),Math.floor(Math.random()*(t.height-1))]),cell(cursor[0],cursor[1])[4]=0,cellsStack.push(cursor);;){let nearCells=getNonVisited(cursor[0],cursor[1]);for(;nearCells.length>0;){let idx,dir;move(nearCells[Math.floor(Math.random()*nearCells.length)].to),nearCells=getNonVisited(cursor[0],cursor[1])}if(!(cursor=cellsStack.pop()))break}}function setGateway(x,y){let start=cell(x,y);0==x?start[0]=1:0==y?start[1]=1:x==t.width-1?start[3]=1:y==t.height-1&&(start[2]=1)}return generate(),t.gates.forEach((v,i)=>{setGateway(v[0],v[1])}),window.maze=maze,maze}resetGates(){this.gates=[]}}